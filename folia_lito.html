<!doctype html>
<html lang="sk">
<head>
  <meta charset="utf-8">
  <title>folia_lito</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
﻿:root { --ink:#0f172a; --panel:#ffffff; --border:#e2e8f0; --bg:#f6f7f9; --accent:#0ea5e9; }
*{box-sizing:border-box;}
body{margin:0;font-family:"Roboto","Noto Sans",system-ui,-apple-system,Segoe UI,Arial,sans-serif;background:var(--bg);color:var(--ink);}
#app{display:grid;grid-template-columns:260px 1fr;gap:12px;height:100vh;padding:12px;min-height:0;}
#controls{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:12px;overflow:auto;}
#controls label{display:flex;align-items:center;justify-content:space-between;gap:4px;font-size:14px;margin:8px 0;}
#controls input,#controls select{width:120px;padding:6px 8px;border:1px solid #cbd5e1;border-radius:8px;font-size:13px;}
#controls input[type=range]{width:160px;}
#controls button{border:none;border-radius:10px;padding:8px 12px;font-weight:600;color:#fff;background:var(--accent);cursor:pointer;}
#controls button.secondary{background:#334155;}
#controls button.warn{background:#dc2626;}
#controls button.btn-compact{padding:6px 10px;font-size:12px;}
#controls .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
#controls .action-buttons{display:flex;flex-direction:column;gap:6px;align-items:stretch;width:100%;}
#controls .action-buttons button{display:inline-flex;width:100%;justify-content:center;background:#0ea5e9;color:#fff;}
  #controls .action-buttons button.secondary{background:#334155;}
  #controls .action-buttons button.warn{background:#dc2626;}
  #controls .active-btn{background:#16a34a !important;color:#fff !important;}
  #noteInput{position:absolute;z-index:6;display:none;min-width:180px;min-height:60px;padding:6px 8px;border:1px solid #cbd5e1;border-radius:8px;font-size:13px;background:#fff;resize:both;}
#controls .sep{height:1px;background:var(--border);margin:10px 0;}
#canvas-wrap{background:#fff;border:1px solid var(--border);border-radius:12px;overflow:hidden;min-height:0;display:flex;position:relative;}
#svgHolder{flex:1;min-height:600px;}
  svg{display:block;width:100%;height:100%;}
  .photo-title{font-weight:700;font-size:13px;letter-spacing:0.04em;}
  .section-title{font-weight:700;font-size:15px;margin:6px 0 4px 0;}
  .vec-item{border:1px solid var(--border);border-radius:10px;padding:8px;margin-top:6px;background:#0b1220;}
  .vec-item.selected{border-color:#2563eb;box-shadow:0 0 0 2px rgba(37,99,235,0.2);}

</style>
</head>
<body>
  <div id="app">
    <aside id="controls">
      <label>Hrubka ciary:
        <input type="number" id="strokeWidth" value="0.8" step="0.2" min="0.2" max="5">
      </label>
      <div class="row" style="gap:6px;flex-wrap:wrap;margin-top:4px;">
        <label style="flex:1;">Jednotky:
          <select id="units">
            <option value="none" selected>Ziadne</option>
            <option value="mm">mm</option>
          </select>
        </label>
        <label style="flex:1;">Desatinne miesta:
          <select id="decimals">
            <option value="0" selected>0</option>
            <option value="1">1</option>
            <option value="2">2</option>
          </select>
        </label>
      </div>

      <label>Vyska: <input type="number" id="W" value="400"></label>
      <div class="section-title">Rozdelenie vysky</div>
      <div style="margin:4px 0 8px 0; display:flex; align-items:center; gap:8px;">
        <button id="segH-add" type="button" aria-label="Pridat" style="width:32px;padding:6px 0;font-size:16px;">+</button>
        <button id="segH-remove" type="button" aria-label="Odobrat" style="width:32px;padding:6px 0;font-size:16px;">-</button>
        <select id="lineStyleH" title="Styl ciar vysky" style="flex:1;">
          <option value="solid" selected>plna</option>
          <option value="dashed">prerusovana</option>
        </select>
      </div>
      <div id="segmentsH" style="display:grid; gap:6px;"></div>
      <div class="row" style="gap:6px;flex-wrap:wrap;margin-top:4px;">
        <label style="flex:1;">Koty vysky:
          <select id="dimPosH" title="Strana kot vysky">
            <option value="right" selected>vpravo</option>
            <option value="left">vlavo</option>
          </select>
        </label>
        <label style="flex:1;">Odsadenie vysky:
          <input type="number" id="dimOffsetH" value="25" step="2" min="0">
        </label>
      </div>

      <label>Sirka: <input type="number" id="L" value="600"></label>
      <div class="section-title">Rozdelenie sirky</div>
      <div style="margin:4px 0 4px 0; display:flex; align-items:center; gap:8px;">
        <button id="seg-add" type="button" aria-label="Pridat" style="width:32px;padding:6px 0;font-size:16px;">+</button>
        <button id="seg-remove" type="button" aria-label="Odobrat" style="width:32px;padding:6px 0;font-size:16px;">-</button>
        <select id="lineStyle" title="Styl ciar" style="flex:1;">
          <option value="solid" selected>plna</option>
          <option value="dashed">prerusovana</option>
        </select>
      </div>
      <div id="segments" style="display:grid; gap:6px; margin-bottom:6px;"></div>
      <div class="row" style="gap:6px;flex-wrap:wrap;">
        <label style="flex:1;">Koty sirky:
          <select id="dimPos">
            <option value="bottom" selected>dole</option>
            <option value="top">hore</option>
          </select>
        </label>
        <label style="flex:1;">Odsadenie koty:
          <input type="number" id="dimOffset" value="25" step="2" min="0">
        </label>
      </div>

      <span class="sep"></span>
      <div style="display:grid; gap:8px;">
      <div class="section-title">Zobrazit navin</div>
        <label><input type="checkbox" id="rollEnabled" checked> Zobrazit navin</label>
        <label>Finalny navin:
          <select id="rollType" style="width:130px;">
            <option value="1" selected>1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
          </select>
        </label>
        <label>Varianta navinu:
          <select id="rollVariant" style="width:130px;">
            <option value="A" selected>A</option>
            <option value="B">B</option>
            <option value="C">C</option>
            <option value="D">D</option>
            <option value="E">E</option>
          </select>
        </label>
        <div class="section-title">Rozmer fotoznaku</div>
        <div class="row" style="gap:6px;flex-wrap:wrap;">
          <label style="flex:1;">Sirka (mm): <input type="number" id="photoW" value="15" min="1"></label>
          <label style="flex:1;">Vyska (mm): <input type="number" id="photoH" value="7" min="1"></label>
        </div>
        <div class="section-title">Fotobunka (dokreslit)</div>
        <div class="row" style="gap:6px;flex-wrap:wrap;">
          <button id="photo-add" type="button" class="secondary" style="flex:1;">Pridat fotobunku</button>
          <button id="photo-remove" type="button" class="secondary" style="flex:1;">Zmazat poslednu</button>
        </div>
        <label><input type="checkbox" id="photo-dims"> Zobrazit rozmery fotobunky (vybrata)</label>
      </div>
      <span class="sep"></span>
        <label>Velkost textu:
          <div class="row">
            <input type="range" id="fontPx" min="6" max="28" value="14">
            <span id="fontPxVal">14 px</span>
          </div>
        </label>
      <label>Meranie (H/V):
        <select id="measureMode">
          <option value="off" selected>vypnute</option>
          <option value="h">horizontalne</option>
          <option value="v">vertikalne</option>
        </select>
      </label>
      <div class="row" style="gap:6px;">
        <button id="measure-cancel" type="button" class="secondary btn-compact">Zrusit meranie</button>
        <button id="measure-clear" type="button" class="warn btn-compact">Vymazat merania</button>
      </div>
      <div class="section-title">Poznamky s vynasacou</div>
      <div class="row" style="gap:6px;flex-wrap:wrap;">
        <button id="note-add" type="button" class="secondary" style="flex:1;">Pridat poznamku</button>
        <button id="note-edit" type="button" class="secondary" style="flex:1;">Editovat poznamku</button>
        <button id="note-delete" type="button" class="warn" style="flex:1;">Vymazat poznamku</button>
      </div>
        <label><input type="checkbox" id="toggle-grid"> Mriezka</label>
      <span class="sep"></span>
        <label>Podkladovy obrazok (PNG/JPG):
          <input type="file" id="bgFile" accept="image/png,image/jpeg,image/webp,image/gif">
        </label>
        <div class="row" style="gap:6px;flex-wrap:wrap;">
          <button id="bg-lock" type="button" class="secondary" style="flex:1;">Zamknut podklad</button>
        </div>
        <div class="section-title">Vektory (SVG)</div>
        <div class="row" style="gap:6px;flex-wrap:wrap;">
          <button id="vec-add" type="button" class="secondary" style="flex:1;">Pridat vektor</button>
        </div>
        <div id="vecList"></div>
      <div class="row" style="gap:6px;flex-wrap:wrap;">
        <label style="flex:1;">Sirka podkladu (mm): <input type="number" id="bgWidth" min="0"></label>
        <label style="flex:1;">Vyska podkladu (mm): <input type="number" id="bgHeight" min="0"></label>
      </div>
      <div class="row" style="gap:6px;flex-wrap:wrap;">
        <button type="button" id="bg-rot-left" class="secondary" style="flex:1;">Otocit -90</button>
        <button type="button" id="bg-rot-180" class="secondary" style="flex:1;">Otocit 180</button>
        <button type="button" id="bg-flip" class="secondary" style="flex:1;">Zrkadlit horiz.</button>
      </div>
      <label>Priehladnost podkladu:
        <div class="row">
          <input type="range" id="bgOpacity" min="0" max="1" step="0.05" value="0.6">
          <span id="bgOpacityVal">60 %</span>
        </div>
      </label>
      <div class="row" style="gap:6px;flex-wrap:wrap;">
        <button id="bg-calib" type="button" class="secondary">Kalibracia podkladu</button>
        <button id="bg-calib-cancel" type="button" class="warn" style="display:none;">Zrusit kalibraciu</button>
        <button id="bg-clear" type="button" class="secondary">Vymazat obrazok</button>
      </div>
      <span class="sep"></span>
      <div class="row" style="gap:8px;flex-wrap:wrap;margin-top:4px;">
        <label style="display:flex;align-items:center;gap:6px;">Tlac A3 orientacia:
          <select id="exportOrient">
            <option value="portrait" selected>na vysku</option>
            <option value="landscape">na sirku</option>
          </select>
        </label>
      </div>
      <div class="row action-buttons" style="margin-top:10px;">
        <button id="btn-reset" class="secondary">Reset</button>
        <button id="btn-export">Export PDF 1:1</button>
        <button id="btn-export-png">Export PNG</button>
        <button id="btn-save" type="button">Ulozit (JSON)</button>
        <button id="btn-load" type="button">Nacitat</button>
        <input type="file" id="loadFile" accept="application/json" style="display:none;">
      </div>
    </aside>

    <section id="canvas-wrap">
      <div id="svgHolder">
        <svg id="svgRoot" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 800" aria-label="nahlad"></svg>
      </div>
      <textarea id="noteInput" placeholder="poznamka"></textarea>
    </section>
  </div>

  <script>
﻿const $ = (id)=>document.getElementById(id);
const svgRoot = $('svgRoot');

const state = {
  fontPx:14,
  bounds:{width:800,height:800},
  segments:[],
  segmentsH:[],
  units:'mm',
  decimals:0,
  rollCode:'1',
  rollType:'std',
  rollEnabled:true,
  rollVariant:'A',
  photoW:15,
  photoH:7,
  photoMarks:[],
  selectedPhotoIndex:-1,
  bgImageData:null,
    bgOpacity:0.6,
    bgWidth:null,
    bgHeight:null,
    bgOffsetX:0,
    bgOffsetY:0,
    bgRot:0,
    bgFlip:false,
    lockBg:false,
  vecItems:[],
  selectedVec:-1,
  calibActive:false,
  calibPoints:[],
  measureMode:'off',
  measurePick:null,
  measures:[],
  measurePreview:null,
  noteMode:'off',
  notes:[],
  noteDraft:null,
  notePreview:null,
  noteEditIndex:-1
};

const inputs = [
  'W','L','fontPx','toggle-grid','lineStyle','lineStyleH','strokeWidth',
  'dimPos','dimOffset','dimPosH','dimOffsetH','units','decimals',
'rollEnabled','rollType','rollVariant','photoW','photoH','exportOrient','bgWidth','bgHeight','bgOpacity','measureMode'
].map(id=>$(id));

function num(el, fallback=0){ const v=parseFloat(el?.value); return Number.isFinite(v)?v:fallback; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function create(tag, attrs={}, parent=svgRoot){
  const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
  Object.entries(attrs).forEach(([k,v])=> el.setAttribute(k,v));
  parent.appendChild(el);
  return el;
}
function clearSvg(){ while(svgRoot.firstChild) svgRoot.removeChild(svgRoot.firstChild); }
  function applyMatrix(pt, m){
    if(!m) return {x:pt.x, y:pt.y};
    return { x: m.a * pt.x + m.c * pt.y + m.e, y: m.b * pt.x + m.d * pt.y + m.f };
  }
  function setNoteMode(mode){
    state.noteMode = mode;
    const addBtn = $('note-add');
    const editBtn = $('note-edit');
    if(addBtn) addBtn.classList.toggle('active-btn', mode === 'on');
    if(editBtn) editBtn.classList.toggle('active-btn', mode === 'edit');
    if(mode === 'off'){
      const input = $('noteInput');
      if(input) input.style.display = 'none';
      svgRoot.style.cursor = '';
    } else {
      svgRoot.style.cursor = 'crosshair';
    }
  }
  function syncLockButtons(){
    const bgBtn = $('bg-lock');
    if(bgBtn) bgBtn.classList.toggle('active-btn', !!state.lockBg);
  }
  function setSelectedVec(idx){
    state.selectedVec = idx;
    document.querySelectorAll('.vec-item').forEach((el,i)=>{
      el.classList.toggle('selected', i === idx);
    });
  }
  function renderVecList(){
    const list = $('vecList');
    if(!list) return;
    list.innerHTML = '';
    state.vecItems.forEach((v, idx)=>{
      if(!v) return;
      if(!Number.isFinite(v.x)) v.x = 0;
      if(!Number.isFinite(v.y)) v.y = 0;
      if(!Number.isFinite(v.scale)) v.scale = 1;
      if(!Number.isFinite(v.rot)) v.rot = 0;
      v.lock = !!v.lock;
      const wrap = document.createElement('div');
      wrap.className = 'vec-item' + (idx === state.selectedVec ? ' selected' : '');
      wrap.addEventListener('click', (e)=>{
        if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON' || e.target.tagName === 'LABEL')) return;
        setSelectedVec(idx);
        draw();
      });

      const title = document.createElement('div');
      title.className = 'photo-title';
      title.textContent = `Vektor ${idx + 1}`;
      wrap.appendChild(title);

      const selectRow = document.createElement('div');
      selectRow.className = 'row';
      selectRow.style.gap = '6px';
      selectRow.style.flexWrap = 'wrap';
      const selectBtn = document.createElement('button');
      selectBtn.type = 'button';
      selectBtn.className = 'secondary';
      selectBtn.style.flex = '1';
      selectBtn.textContent = 'Vybrat';
      selectBtn.addEventListener('click', ()=>{
        setSelectedVec(idx);
        draw();
      });
      selectRow.appendChild(selectBtn);
      wrap.appendChild(selectRow);

      const fileRow = document.createElement('div');
      fileRow.className = 'row';
      fileRow.style.gap = '6px';
      fileRow.style.flexWrap = 'wrap';
      const fileLabel = document.createElement('label');
      fileLabel.style.flex = '1';
      fileLabel.textContent = 'SVG subor: ';
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = 'image/svg+xml';
      fileInput.addEventListener('click', (e)=>{ e.target.value = ''; });
      fileInput.addEventListener('change', (e)=>{
        const file = e.target.files && e.target.files[0];
        if(!file) return;
        const r = new FileReader();
        r.onload = (ev)=>{ v.svg = ev.target.result; setSelectedVec(idx); draw(); };
        r.readAsText(file);
      });
      fileLabel.appendChild(fileInput);
      fileRow.appendChild(fileLabel);
      wrap.appendChild(fileRow);

      const row1 = document.createElement('div');
      row1.className = 'row';
      row1.style.gap = '6px';
      row1.style.flexWrap = 'wrap';
      const scaleLabel = document.createElement('label');
      scaleLabel.style.flex = '1';
      scaleLabel.textContent = 'Mierka (%) ';
      const scaleInput = document.createElement('input');
      scaleInput.type = 'number';
      scaleInput.min = '10';
      scaleInput.max = '500';
      scaleInput.value = Math.round(v.scale * 100);
      scaleInput.id = `vec-scale-${idx}`;
      scaleInput.addEventListener('input', ()=>{
        v.scale = num(scaleInput, 100) / 100;
        draw();
      });
      scaleLabel.appendChild(scaleInput);
      row1.appendChild(scaleLabel);

      const rotLabel = document.createElement('label');
      rotLabel.style.flex = '1';
      rotLabel.textContent = 'Otocenie (deg) ';
      const rotInput = document.createElement('input');
      rotInput.type = 'number';
      rotInput.step = '1';
      rotInput.value = v.rot;
      rotInput.id = `vec-rot-${idx}`;
      rotInput.addEventListener('input', ()=>{
        v.rot = num(rotInput, 0);
        draw();
      });
      rotLabel.appendChild(rotInput);
      row1.appendChild(rotLabel);
      wrap.appendChild(row1);

      const row2 = document.createElement('div');
      row2.className = 'row';
      row2.style.gap = '6px';
      row2.style.flexWrap = 'wrap';
      const lockBtn = document.createElement('button');
      lockBtn.type = 'button';
      lockBtn.className = 'secondary' + (v.lock ? ' active-btn' : '');
      lockBtn.style.flex = '1';
      lockBtn.textContent = 'Zamknut';
      lockBtn.addEventListener('click', ()=>{
        v.lock = !v.lock;
        lockBtn.classList.toggle('active-btn', v.lock);
        if(v.lock && state.selectedVec === idx) setSelectedVec(-1);
        draw();
      });
      const resetBtn = document.createElement('button');
      resetBtn.type = 'button';
      resetBtn.className = 'secondary';
      resetBtn.style.flex = '1';
      resetBtn.textContent = 'Reset';
      resetBtn.addEventListener('click', ()=>{
        v.x = 0; v.y = 0; v.scale = 1; v.rot = 0;
        scaleInput.value = 100;
        rotInput.value = 0;
        draw();
      });
      const delBtn = document.createElement('button');
      delBtn.type = 'button';
      delBtn.className = 'warn';
      delBtn.style.flex = '1';
      delBtn.textContent = 'Vymazat';
      delBtn.addEventListener('click', ()=>{
        state.vecItems.splice(idx,1);
        if(state.selectedVec === idx) state.selectedVec = -1;
        if(state.selectedVec > idx) state.selectedVec -= 1;
        renderVecList();
        draw();
      });
      row2.appendChild(lockBtn);
      row2.appendChild(resetBtn);
      row2.appendChild(delBtn);
      wrap.appendChild(row2);

      list.appendChild(wrap);
    });
  }
  function rectToSvgBBox(rect){
    const ctm = svgRoot.getScreenCTM();
    if(!ctm) return null;
    const inv = ctm.inverse();
    const p1 = svgRoot.createSVGPoint();
    p1.x = rect.left; p1.y = rect.top;
    const p2 = svgRoot.createSVGPoint();
    p2.x = rect.right; p2.y = rect.bottom;
    const sp1 = p1.matrixTransform(inv);
    const sp2 = p2.matrixTransform(inv);
    const minX = Math.min(sp1.x, sp2.x);
    const minY = Math.min(sp1.y, sp2.y);
    const maxX = Math.max(sp1.x, sp2.x);
    const maxY = Math.max(sp1.y, sp2.y);
    if(!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) return null;
    return { x:minX, y:minY, width:maxX - minX, height:maxY - minY };
  }
  function computeVecBBox(meta, originX, originY, scale, rotDeg){
    if(!meta) return null;
    const s = Number.isFinite(scale) ? scale : 1;
    const ang = (Number.isFinite(rotDeg) ? rotDeg : 0) * Math.PI / 180;
    const cos = Math.cos(ang);
    const sin = Math.sin(ang);
    const pts = [
      {x: meta.vbMinX, y: meta.vbMinY},
      {x: meta.vbMinX + meta.vbW, y: meta.vbMinY},
      {x: meta.vbMinX, y: meta.vbMinY + meta.vbH},
      {x: meta.vbMinX + meta.vbW, y: meta.vbMinY + meta.vbH}
    ].map(p=>{
      const x = p.x * s;
      const y = p.y * s;
      const xr = x * cos - y * sin;
      const yr = x * sin + y * cos;
      return {x: xr + originX, y: yr + originY};
    });
    const xs = pts.map(p=>p.x);
    const ys = pts.map(p=>p.y);
    const minX = Math.min(...xs);
    const minY = Math.min(...ys);
    const maxX = Math.max(...xs);
    const maxY = Math.max(...ys);
    return {x:minX, y:minY, width:maxX - minX, height:maxY - minY};
  }
function bboxToSvg(bb, m){
  const pts = [
    {x: bb.x, y: bb.y},
    {x: bb.x + bb.width, y: bb.y},
    {x: bb.x, y: bb.y + bb.height},
    {x: bb.x + bb.width, y: bb.y + bb.height}
  ].map(p => applyMatrix(p, m));
  const xs = pts.map(p=>p.x);
  const ys = pts.map(p=>p.y);
  const minX = Math.min(...xs);
  const minY = Math.min(...ys);
  const maxX = Math.max(...xs);
  const maxY = Math.max(...ys);
  return { x:minX, y:minY, width:maxX - minX, height:maxY - minY, corners: pts };
}

function ensureDefs(){
  if(svgRoot.querySelector('#arrow-roll')) return;
  const defs = create('defs');
  const marker = create('marker',{id:'arrow-roll',viewBox:'0 0 21 21',refX:'12',refY:'10.5',markerWidth:'15',markerHeight:'15',orient:'auto',markerUnits:'userSpaceOnUse'},defs);
  create('path',{d:'M 0 0 L 21 10.5 L 0 21 z',fill:'#0f172a'},marker);
}

function addSegmentInput(val=''){
  const wrap = document.createElement('div');
  wrap.style.display='flex'; wrap.style.gap='6px'; wrap.style.alignItems='center';
  const lab = document.createElement('span'); lab.textContent = `cast S ${state.segments.length+1}:`; lab.style.fontSize='13px';
  const inp = document.createElement('input'); inp.type='number'; inp.min='0'; inp.value = val; inp.style.flex='1'; inp.className='seg-input';
  inp.addEventListener('input', draw);
  wrap.appendChild(lab); wrap.appendChild(inp);
  $('segments').appendChild(wrap);
  state.segments.push(inp);
}
function removeSegmentInput(){
  if(state.segments.length===0) return;
  const inp = state.segments.pop();
  inp.parentElement?.remove();
  draw();
}

function addSegmentInputH(val=''){
  const wrap = document.createElement('div');
  wrap.style.display='flex'; wrap.style.gap='6px'; wrap.style.alignItems='center';
  const lab = document.createElement('span'); lab.textContent = `cast V ${state.segmentsH.length+1}:`; lab.style.fontSize='13px';
  const inp = document.createElement('input'); inp.type='number'; inp.min='0'; inp.value = val; inp.style.flex='1'; inp.className='segH-input';
  inp.addEventListener('input', draw);
  wrap.appendChild(lab); wrap.appendChild(inp);
  $('segmentsH').appendChild(wrap);
  state.segmentsH.push(inp);
}
function removeSegmentInputH(){
  if(state.segmentsH.length===0) return;
  const inp = state.segmentsH.pop();
  inp.parentElement?.remove();
  draw();
}

function textWithBg(txt,x,y,opts={}){
  const {
    color='#0f172a',
    anchor='middle',
    baseline='middle',
    parent=svgRoot,
    fontSize=null,
    fontWeight=null,
    boxWidth=null,
    boxHeight=null
  } = opts;
  const g = create('g',{},parent);
  const tAttrs = {x,y,'text-anchor':anchor,'dominant-baseline':baseline,fill:color,'font-size': fontSize || state.fontPx};
  if(fontWeight) tAttrs['font-weight'] = fontWeight;
  const t = create('text',tAttrs,g);
  t.textContent = txt;
  const bb = t.getBBox();
  if(boxWidth && boxHeight){
    const cx = bb.x + bb.width/2;
    const cy = bb.y + bb.height/2;
    const r = create('rect',{x:cx - boxWidth/2,y:cy - boxHeight/2,width:boxWidth,height:boxHeight,fill:'white',opacity:'0.9'});
    g.insertBefore(r,t);
    return g;
  }
  const padX=1, padY=0;
  const r = create('rect',{x:bb.x-padX,y:bb.y-padY,width:bb.width+2*padX,height:bb.height+2*padY,fill:'white',opacity:'0.9'});
  g.insertBefore(r,t);
  return g;
}
const arrowLeft=(x,y,c,p=svgRoot)=>create('path',{d:`M ${x} ${y} l 6 -4 v 8 z`,fill:c},p);
const arrowRight=(x,y,c,p=svgRoot)=>create('path',{d:`M ${x} ${y} l -6 -4 v 8 z`,fill:c},p);
const arrowUp=(x,y,c,p=svgRoot)=>create('path',{d:`M ${x} ${y} l -4 6 h 8 z`,fill:c},p);
const arrowDown=(x,y,c,p=svgRoot)=>create('path',{d:`M ${x} ${y} l -4 -6 h 8 z`,fill:c},p);

function formatVal(v){
  const d = state.decimals ?? 0;
  const pow = Math.pow(10,d);
  const rounded = Math.round(v * pow) / pow;
  const numStr = rounded.toFixed(d);
  return state.units === 'mm' ? `${numStr} mm` : numStr;
}
function formatPlain(v){
  const d = state.decimals ?? 0;
  const pow = Math.pow(10,d);
  return (Math.round(v * pow) / pow).toFixed(d);
}

function hDim(x1,y,x2,val,ext=10,color='#0f172a', fontScale=1, textOffset=null, useUnits=true, parent=svgRoot){
  if(x2<x1){ const t=x1; x1=x2; x2=t; }
  const sw = state.strokeWidth || 1;
  create('line',{x1,y1:y,x2,y2:y,stroke:color,'stroke-width':sw}, parent);
  create('line',{x1,y1:y-ext,x2:x1,y2:y+ext,stroke:color,'stroke-width':sw}, parent);
  create('line',{x1:x2,y1:y-ext,x2:x2,y2:y+ext,stroke:color,'stroke-width':sw}, parent);
  arrowLeft(x1,y,color,parent); arrowRight(x2,y,color,parent);
  const original = state.fontPx;
  state.fontPx = Math.max(6, original * fontScale);
  const txtOffset = (textOffset!==null ? textOffset : 6);
  const label = useUnits ? formatVal(val) : formatPlain(val);
  const g = parent || svgRoot;
  textWithBg(label,(x1+x2)/2,y-txtOffset,{color,parent:g});
  state.fontPx = original;
}
function vDim(x,y1,y2,val,ext=10,color='#0f172a', fontScale=1, textOffset=null, useUnits=true, parent=svgRoot){
  if(y2<y1){ const t=y1; y1=y2; y2=t; }
  const sw = state.strokeWidth || 1;
  create('line',{x1:x,x2:x,y1,y2,stroke:color,'stroke-width':sw}, parent);
  create('line',{x1:x-ext,x2:x+ext,y1:y1,y2:y1,stroke:color,'stroke-width':sw}, parent);
  create('line',{x1:x-ext,x2:x+ext,y1:y2,y2:y2,stroke:color,'stroke-width':sw}, parent);
  arrowUp(x,y1,color,parent); arrowDown(x,y2,color,parent);
  const baseOffset = Math.max(1, ext*0.6 + Math.round(state.fontPx*0.12));
  const offset = (textOffset!==null ? textOffset : baseOffset);
  const g = create('g',{transform:`translate(${x - offset} ${(y1+y2)/2}) rotate(-90)`}, parent);
  const original = state.fontPx;
  state.fontPx = Math.max(6, original * fontScale);
  const t = create('text',{'text-anchor':'middle','dominant-baseline':'middle','font-size':state.fontPx,fill:color},g);
  t.textContent = useUnits ? formatVal(val) : formatPlain(val);
  state.fontPx = original;
}

function drawMeasurements(parent){
  const tgt = parent || svgRoot;
  for(const m of state.measures){
    if(m.type==='h'){
      hDim(m.x1, m.y1, m.x2, Math.abs(m.x2-m.x1), 8, '#16a34a', 0.95, null, true, tgt);
    }else if(m.type==='v'){
      vDim(m.x1, m.y1, m.y2, Math.abs(m.y2-m.y1), 8, '#16a34a', 0.95, null, true, tgt);
    }
  }
  if(state.measurePreview){
    const m = state.measurePreview;
    if(m.type==='h'){
      hDim(m.x1, m.y1, m.x2, Math.abs(m.x2-m.x1), 8, '#22c55e', 0.95, null, true, tgt);
    }else if(m.type==='v'){
      vDim(m.x1, m.y1, m.y2, Math.abs(m.y2-m.y1), 8, '#22c55e', 0.95, null, true, tgt);
    }
  }
}

function draw(){
  const W = num($('W'),400);
  const L = num($('L'),600);
  state.fontPx = parseInt($('fontPx')?.value,10)||14;
  $('fontPxVal').textContent = state.fontPx + ' px';
  const lineStyle = $('lineStyle')?.value === 'dashed' ? '6 4' : null;
  const lineStyleH = $('lineStyleH')?.value === 'dashed' ? '6 4' : null;
  state.strokeWidth = Math.max(0.2, num($('strokeWidth'),1));
  state.units = $('units')?.value || 'none';
  state.decimals = parseInt($('decimals')?.value,10) || 0;
  const dimPos = $('dimPos')?.value || 'bottom';
  let dimPosEff = dimPos;
  const dimOffsetVal = Math.max(0, num($('dimOffset'), 80));
  const dimPosH = $('dimPosH')?.value || 'right';
  const dimOffsetH = Math.max(0, num($('dimOffsetH'), 25));
  state.rollEnabled = !!$('rollEnabled')?.checked;
  state.rollCode = $('rollType')?.value || '1';
  state.rollVariant = $('rollVariant')?.value || 'A';
  state.photoW = num($('photoW'),15);
  state.photoH = num($('photoH'),7);
  // vypocet efektivneho navinu podla tlace/montaze
  const finalCode = state.rollCode;
  const finalVariant = state.rollVariant;
  const printMap = {
    '1A':{code:'2',variant:'A'}, '1B':{code:'2',variant:'C'}, '1C':{code:'2',variant:'B'}, '1D':{code:'2',variant:'D'}, '1E':{code:'2',variant:'E'},
    '2A':{code:'1',variant:'A'}, '2B':{code:'1',variant:'C'}, '2C':{code:'1',variant:'B'}, '2D':{code:'1',variant:'D'}, '2E':{code:'1',variant:'E'},
    '3A':{code:'4',variant:'A'}, '3B':{code:'4',variant:'C'}, '3C':{code:'4',variant:'B'}, '3D':{code:'4',variant:'D'}, '3E':{code:'4',variant:'D'},
    '4A':{code:'3',variant:'A'}, '4B':{code:'3',variant:'C'}, '4C':{code:'3',variant:'B'}, '4D':{code:'3',variant:'D'}, '4E':{code:'4',variant:'E'},
    '5A':{code:'6',variant:'A'}, '5B':{code:'6',variant:'C'}, '5C':{code:'6',variant:'B'}, '5D':{code:'6',variant:'D'}, '5E':{code:'6',variant:'E'},
    '6A':{code:'5',variant:'A'}, '6B':{code:'6',variant:'C'}, '6C':{code:'5',variant:'B'}, '6D':{code:'5',variant:'D'}, '6E':{code:'5',variant:'E'},
    '7A':{code:'8',variant:'A'}, '7B':{code:'7',variant:'C'}, '7C':{code:'8',variant:'B'}, '7D':{code:'8',variant:'D'}, '7E':{code:'8',variant:'E'},
    '8A':{code:'7',variant:'A'}, '8B':{code:'7',variant:'C'}, '8C':{code:'7',variant:'B'}, '8D':{code:'7',variant:'D'}, '8E':{code:'7',variant:'E'}
  };
  let effectiveCode = finalCode;
  let effectiveVariant = finalVariant;
  let navinMode = 'finalny';
  const rotatePrint = false;
  // bez navin tlac/montaz logiky
  const rollTypeEffective = (['1','2','5','6'].includes(effectiveCode) ? 'std' : 'alt');
  const rollCodeDraw = effectiveCode;
  const rollVariantDraw = effectiveVariant;
  const rollTypeDraw = rollTypeEffective;
  let navinLabelText = `Navin: ${rollCodeDraw}${rollVariantDraw} (${navinMode})`;
  if(navinMode==='finalny'){
    navinLabelText = `Finalny navin: ${rollCodeDraw}${rollVariantDraw}`;
  }
  const mirrorABC = false;
  state.rollType = (['1','2','5','6'].includes(state.rollCode) ? 'std' : 'alt');
  state.bgOpacity = clamp(num($('bgOpacity'), 0.6),0,1);
  $('bgOpacityVal').textContent = `${Math.round(state.bgOpacity*100)} %`;
  state.bgWidth = $('bgWidth')?.value ? num($('bgWidth'), null) : null;
  state.bgHeight = $('bgHeight')?.value ? num($('bgHeight'), null) : null;

  const offsetX=60, offsetY=80;
  state.drawDims = { offsetX, offsetY, L, W };
  const baseDimOffset = dimOffsetVal;
  const yTop=offsetY, yBottom=offsetY+W;

  clearSvg();
  const allGroup = create('g',{class:'content-bbox'});
  const contentGroup = create('g',{class:'content-core'}, allGroup);
  const rollGroup = create('g',{class:'roll-group'}, allGroup);

  if($('toggle-grid')?.checked){
    const gridPad = 200;
    const gx = offsetX - gridPad;
    const gy = offsetY - gridPad;
    const gW = L + gridPad*2;
    const gH = W + gridPad*2;
    const gridStep = 50;
    const gridGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
    gridGroup.setAttribute('stroke','#e2e8f0');
    gridGroup.setAttribute('stroke-width','1');
    for(let x=Math.floor(gx/gridStep)*gridStep; x<=gx+gW; x+=gridStep){
      create('line',{x1:x,y1:gy,x2:x,y2:gy+gH},gridGroup);
    }
    for(let y=Math.floor(gy/gridStep)*gridStep; y<=gy+gH; y+=gridStep){
      create('line',{x1:gx,y1:y,x2:gx+gW,y2:y},gridGroup);
    }
    svgRoot.appendChild(gridGroup);
  }

  // podklad
  if (state.bgImageData){
    const bgW = state.bgWidth ?? L;
    const bgH = state.bgHeight ?? W;
    const cx = offsetX + state.bgOffsetX + bgW/2;
    const cy = offsetY + state.bgOffsetY + bgH/2;
    const transforms = [];
    if(state.bgRot % 360 !== 0){ transforms.push(`rotate(${state.bgRot} ${cx} ${cy})`); }
    if(state.bgFlip){ transforms.push(`translate(${2*cx} 0) scale(-1 1)`); }
    const img = create('image',{
      href: state.bgImageData,
      x: offsetX + state.bgOffsetX,
      y: offsetY + state.bgOffsetY,
      width: bgW,
      height: bgH,
      opacity: state.bgOpacity
    }, contentGroup);
    if(transforms.length){ img.setAttribute('transform', transforms.join(' ')); }
  }

    // vektory (SVG)
    const vecMetas = [];
    const vecOrigins = [];
    if(Array.isArray(state.vecItems)){
      state.vecItems.forEach((v, idx)=>{
        if(!v || !v.svg) return;
        try{
          const parser = new DOMParser();
          const doc = parser.parseFromString(v.svg, 'image/svg+xml');
          const svgEl = doc.documentElement;
          const vbAttr = svgEl.getAttribute('viewBox');
          let vbMinX = 0, vbMinY = 0, vbW = null, vbH = null;
          if(vbAttr){
            const parts = vbAttr.trim().split(/[\s,]+/).map(Number).filter(n=>Number.isFinite(n));
            if(parts.length >= 4){
              vbMinX = parts[0];
              vbMinY = parts[1];
              vbW = parts[2];
              vbH = parts[3];
            }
          }
          const wAttr = parseFloat(svgEl.getAttribute('width') || '');
          const hAttr = parseFloat(svgEl.getAttribute('height') || '');
          if(!Number.isFinite(vbW) && Number.isFinite(wAttr)) vbW = wAttr;
          if(!Number.isFinite(vbH) && Number.isFinite(hAttr)) vbH = hAttr;
          if(!Number.isFinite(vbW) || vbW <= 0) vbW = 100;
          if(!Number.isFinite(vbH) || vbH <= 0) vbH = 100;
          const g = create('g',{class:'vec-shape','data-vec-idx':String(idx)}, contentGroup);
          const tParts = [];
          const vecOriginX = offsetX + (Number.isFinite(v.x) ? v.x : 0);
          const vecOriginY = offsetY + (Number.isFinite(v.y) ? v.y : 0);
          tParts.push(`translate(${vecOriginX} ${vecOriginY})`);
          if(Number.isFinite(v.rot) && v.rot){ tParts.push(`rotate(${v.rot})`); }
          if(Number.isFinite(v.scale) && v.scale !== 1){ tParts.push(`scale(${v.scale})`); }
          g.setAttribute('transform', tParts.join(' '));
          Array.from(svgEl.childNodes).forEach(n=> g.appendChild(svgRoot.ownerDocument.importNode(n, true)));
          vecMetas[idx] = {vbMinX, vbMinY, vbW, vbH};
          vecOrigins[idx] = {x: vecOriginX, y: vecOriginY};
        }catch(_){}
      });
    }

  // hlavny obdlznik
  create('rect',{x:offsetX,y:offsetY,width:L,height:W,fill:'none',stroke:'#0f172a','stroke-width':state.strokeWidth}, contentGroup);

  // delenie sirky
  const segValues = state.segments.map(inp => num(inp,0)).filter(v=>v>0);
  const sumSeg = segValues.reduce((a,b)=>a+b,0);
  const remainder = Math.max(L - sumSeg, 0);
  const parts = [...segValues];
  if (remainder > 0 || parts.length===0) parts.push(remainder);

  // delenie vysky
  const segValuesH = state.segmentsH.map(inp => num(inp,0)).filter(v=>v>0);
  const sumSegH = segValuesH.reduce((a,b)=>a+b,0);
  const remainderH = Math.max(W - sumSegH, 0);
  const partsH = [...segValuesH];
  if (remainderH > 0 || partsH.length===0) partsH.push(remainderH);

  // koty sirky
  const segOffset = Number.isFinite(baseDimOffset) ? baseDimOffset : 25;
  const segY = dimPosEff === 'top' ? yTop - segOffset : yBottom + segOffset;
  let cursor = offsetX;
  parts.forEach((len, idx)=>{
    const next = cursor + len;
    hDim(cursor, segY, next, len, 10, '#0f172a', 0.9, null, true, contentGroup);
    if (idx < parts.length - 1){
      create('line',{x1:next,y1:offsetY,x2:next,y2:offsetY+W,stroke:'#475569','stroke-width':state.strokeWidth,'stroke-dasharray':lineStyle || ''}, contentGroup);
    }
    cursor = next;
  });
  hDim(offsetX, segY + (dimPosEff==='top' ? -20 : 20), offsetX+L, L, 10, '#0f172a', 1.1, null, true, contentGroup);

  // koty vysky
  const segOffsetH = dimOffsetH || Math.max(50, Math.round(state.fontPx*3.2));
  const segX = dimPosH === 'left' ? offsetX - segOffsetH : offsetX + L + segOffsetH;
  cursor = offsetY;
  partsH.forEach((len, idx)=>{
    const next = cursor + len;
    vDim(segX, cursor, next, len, 10, '#0f172a', 0.9, null, true, contentGroup);
    if (idx < partsH.length - 1){
      create('line',{x1:offsetX,y1:next,x2:offsetX+L,y2:next,stroke:'#475569','stroke-width':state.strokeWidth,'stroke-dasharray':lineStyleH || ''}, contentGroup);
    }
    cursor = next;
  });
  vDim(segX + (dimPosH==='left' ? -20 : 20), offsetY, offsetY+W, W, 10, '#0f172a', 1.1, null, true, contentGroup);

  let rollBounds = null;
  // navin (preberene z predchadzajucej verzie)
  const rollActive = state.rollEnabled;
  const mirrorPrint = (navinMode==='tlac');
  const mirrorMontage = (navinMode==='montaz');
  if(rollActive){
    ensureDefs();
    const rollR = Math.max(40, (W/10));
    const innerR = rollR/2;
    const baseYRoll = yTop - 20 - rollR;
    const yRoll = rollTypeDraw === 'alt' ? baseYRoll - 65 : baseYRoll;
    const navParent = create('g',{class:'roll'}, rollGroup);

    if(rollTypeDraw === 'alt'){
      const leftCx = offsetX + rollR;
      const rightCx = offsetX + L;
      create('circle',{cx:leftCx, cy:yRoll, r:rollR, fill:'none', stroke:'#0f172a','stroke-width':state.strokeWidth}, navParent);
      const topRightY = yRoll - rollR;
      const bottomRightY = yRoll + rollR;
      const rightHalfPath = `M ${rightCx} ${topRightY} A ${rollR} ${rollR} 0 0 1 ${rightCx} ${bottomRightY}`;
      create('path',{d:rightHalfPath, fill:'none', stroke:'#0f172a','stroke-width':state.strokeWidth}, navParent);
      create('circle',{cx:leftCx, cy:yRoll, r:innerR, fill:'none', stroke:'#0f172a','stroke-width':state.strokeWidth}, navParent);
      const topY = yRoll - rollR;
      const bottomY = yRoll + rollR;
      create('line',{x1:leftCx,y1:topY,x2:rightCx,y2:topY,stroke:'#0f172a','stroke-width':state.strokeWidth}, navParent);
      create('line',{x1:leftCx,y1:bottomY,x2:rightCx,y2:bottomY,stroke:'#0f172a','stroke-width':state.strokeWidth}, navParent);
      const leftLinkX = leftCx - rollR;
      const leftLinkY = yRoll;
      const leftCornerY = yTop - 5;
      create('line',{x1:leftLinkX,y1:leftLinkY,x2:offsetX,y2:leftCornerY,stroke:'#0f172a','stroke-width':state.strokeWidth}, navParent);
      const rightCornerX = offsetX + L;
      const rightCornerY = yTop - 5;
      create('line',{x1:rightCornerX,y1:rightCornerY,x2:rightCx,y2:bottomY,stroke:'#0f172a','stroke-width':state.strokeWidth}, navParent);
      create('line',{x1:offsetX,y1:leftCornerY,x2:rightCornerX,y2:rightCornerY,stroke:'#0f172a','stroke-width':state.strokeWidth}, navParent);
      const arrowX = offsetX + L/2;
      const arrowEndY = leftCornerY - 5;
      const arrowStartY = arrowEndY - rollR;
      create('line',{x1:arrowX,y1:arrowStartY,x2:arrowX,y2:arrowEndY,stroke:'#0f172a','stroke-width':state.strokeWidth,'marker-end':'url(#arrow-roll)'}, navParent);
      rollBounds = {
        minX: leftCx - rollR,
        maxX: rightCx + rollR,
        minY: Math.min(topY, arrowStartY),
        maxY: Math.max(bottomY, arrowEndY)
      };
    } else {
      const leftCx = offsetX - rollR;
      create('circle',{cx:leftCx, cy:yRoll, r:rollR, fill:'none', stroke:'#0f172a','stroke-width':state.strokeWidth}, navParent);
      create('circle',{cx:leftCx, cy:yRoll, r:innerR, fill:'none', stroke:'#0f172a','stroke-width':state.strokeWidth}, navParent);
      const leftTouchX = leftCx + rollR;
      const leftCornerX = offsetX;
      const leftCornerY = yTop - 5;
      create('line',{x1:leftTouchX,y1:yRoll,x2:leftCornerX,y2:leftCornerY,stroke:'#0f172a','stroke-width':state.strokeWidth}, navParent);

      const rightCornerX = offsetX + L;
      const rightCornerY = yTop - 5;
      const arcStartX = rightCornerX - rollR;
      const arcStartY = yRoll - rollR;
      const arcEndX = rightCornerX;
      const arcEndY = yRoll;
      create('line',{x1:leftCx,y1:yRoll-rollR,x2:arcStartX,y2:arcStartY,stroke:'#0f172a','stroke-width':state.strokeWidth}, navParent);
      const arcPath = `M ${arcStartX} ${arcStartY} A ${rollR} ${rollR} 0 0 1 ${arcEndX} ${arcEndY}`;
      create('path',{d:arcPath, fill:'none', stroke:'#0f172a','stroke-width':state.strokeWidth}, navParent);
      const lowerEndY = rightCornerY;
      create('line',{x1:arcEndX,y1:arcEndY,x2:rightCornerX,y2:lowerEndY,stroke:'#0f172a','stroke-width':state.strokeWidth}, navParent);
      create('line',{x1:leftCornerX,y1:leftCornerY,x2:rightCornerX,y2:rightCornerY,stroke:'#0f172a','stroke-width':state.strokeWidth}, navParent);
      const leftBottomY = yRoll + rollR;
      create('line',{x1:leftCx,y1:leftBottomY,x2:leftCornerX,y2:leftBottomY,stroke:'#0f172a','stroke-width':state.strokeWidth}, navParent);
      const arrowX = (leftCornerX + rightCornerX) / 2;
      const arrowStartX = arrowX - rollR;
      const arrowStartY = yRoll - rollR;
      const arrowMidX = arrowX;
      const arrowMidY = yRoll;
      const arrowBottomY = yRoll + rollR;
      const arrowPath = `M ${arrowStartX} ${arrowStartY} A ${rollR} ${rollR} 0 0 1 ${arrowMidX} ${arrowMidY} L ${arrowMidX} ${arrowBottomY}`;
      create('path',{d:arrowPath, fill:'none', stroke:'#0f172a','stroke-width':state.strokeWidth,'marker-end':'url(#arrow-roll)'}, navParent);

      rollBounds = {
        minX: Math.min(leftCx - rollR, arcStartX - rollR),
        maxX: Math.max(rightCornerX, leftCx + rollR),
        minY: Math.min(yRoll - rollR, arcStartY),
        maxY: yRoll + rollR
      };
    }

    // jednotne vykreslenie ABC podla typu navinu
    const labelX = offsetX + L/2;
    const rollLabelConfig = {
      '1': {y: yTop - 50, dx: 0, rot: 0},
      '2': {y: yTop - 50, dx: 0, rot: 180},
      '3': {y: yTop - 40, dx: 0, rot: 0},
      '4': {y: yTop - 40, dx: 0, rot: 180},
      '5': {y: yTop - 50, dx: 25, rot: 90},
      '6': {y: yTop - 50, dx: -25, rot: -90},
      '7': {y: yTop - 45, dx: 25, rot: 90},
      '8': {y: yTop - 45, dx: -25, rot: -90}
    };
    const labelCfg = rollLabelConfig[rollCodeDraw];
    if(labelCfg){
      const lx = labelX + (labelCfg.dx || 0);
      const ly = labelCfg.y;
      const g = textWithBg('ABC', lx, ly, {
        anchor:'middle',
        baseline:'middle',
        color:'#0f172a',
        parent:navParent,
        fontSize: 40,
        fontWeight:'700',
        boxWidth:70,
        boxHeight:30
      });
      const tParts = [];
      // mirror musi byt aplikovany po rotacii (poradie transformov je sprava dolava)
      if(mirrorABC){
        tParts.push(`translate(${2*lx} 0) scale(-1 1)`);
      }
      if(labelCfg.rot){
        tParts.push(`rotate(${labelCfg.rot} ${lx} ${ly})`);
      }
      if(tParts.length) g.setAttribute('transform', tParts.join(' '));
    }

  // varianty fotoznakov v navine
    if(['A','B','C','E'].includes(rollVariantDraw)){
      const markW = Math.max(1, Number.isFinite(state.photoW) ? state.photoW : 15);
      const markH = Math.max(1, Number.isFinite(state.photoH) ? state.photoH : 7);
      const topY = yTop - 5 - markH;
    const mirrorMark = false;
    const drawMark = (x)=> {
      const mx = mirrorMark ? (2 * (offsetX + L/2) - (x + markW)) : x;
      create('rect',{x: mx, y:topY, width:markW, height:markH, fill:'#000'}, navParent);
    };
      if(rollVariantDraw==='A' || rollVariantDraw==='B'){
        drawMark(offsetX);
      }
      if(rollVariantDraw==='A' || rollVariantDraw==='C'){
        drawMark(offsetX + L - markW);
      }
      if(rollVariantDraw==='E'){
        const centerX = offsetX + L/2;
        if(['1','2','3','4'].includes(rollCodeDraw)){
          drawMark(centerX + markW/2 + 5);
        }else{
          let posX = centerX;
          if(rollCodeDraw==='5') posX = centerX - 25;
          else if(rollCodeDraw==='6') posX = centerX + 25;
          else if(rollCodeDraw==='7') posX = centerX - 25;
          else if(rollCodeDraw==='8') posX = centerX + 25;
          drawMark(posX - markW/2);
        }
      }
    }

    // rollBounds: ak nie je nastavene, pokryje navin
    if(!rollBounds){
      const bb = navParent.getBBox();
      rollBounds = {minX:bb.x, maxX:bb.x+bb.width, minY:bb.y, maxY:bb.y+bb.height};
    }

    if(mirrorPrint || mirrorMontage){
      // otocime okolo stredu vlastneho bboxu, potom posunieme o dx/dy podla typu
      const bb = navParent.getBBox();
      const cx = bb.x + bb.width/2;
      const cy = bb.y + bb.height/2;
      navParent.setAttribute('transform', `rotate(180 ${cx} ${cy})`);
      const bbRot = navParent.getBBox();
      const dx = (['1','2','5','6'].includes(rollCodeDraw) ? rollR*2 : -rollR);
      const dy = (yBottom + 5) - bbRot.y;
      navParent.setAttribute('transform', `translate(${dx} ${dy}) rotate(180 ${cx} ${cy})`);
      const bb2 = navParent.getBBox();
      rollBounds = {minX:bb2.x, maxX:bb2.x+bb2.width, minY:bb2.y, maxY:bb2.y+bb2.height};
    }
  }

  // fotobunky dokreslene uzivatelom
  if (Array.isArray(state.photoMarks) && state.photoMarks.length) {
    const markW = Math.max(1, Number.isFinite(state.photoW) ? state.photoW : 15);
    const markH = Math.max(1, Number.isFinite(state.photoH) ? state.photoH : 7);
    state.photoMarks.forEach((m, idx) => {
      const isSel = idx === state.selectedPhotoIndex;
      const fillColor = isSel ? '#2563eb' : '#0f172a';
      create('rect',{x:m.x, y:m.y, width:markW, height:markH, fill:fillColor, stroke:fillColor, 'stroke-width':state.strokeWidth}, contentGroup);
      if (m.showDims) {
        const label = `${markW}x${markH}`;
        const lx = m.x + markW + 6;
        const ly = m.y + markH / 2;
        textWithBg(label, lx, ly, {anchor:'start', baseline:'middle', parent:contentGroup, color:'#0f172a', fontWeight:'400', fontSize:state.fontPx});
      }
    });
  }

  // poznamky s vynasacou
    const drawNoteText = (txt, x, y) => {
      const g = create('g',{}, contentGroup);
      const lines = String(txt || '').split(/\r?\n/);
      const t = create('text',{'text-anchor':'start','dominant-baseline':'middle','font-size':state.fontPx,fill:'#0f172a'}, g);
      lines.forEach((line, i) => {
        const span = document.createElementNS('http://www.w3.org/2000/svg','tspan');
        span.setAttribute('x', x);
        span.setAttribute('y', y + i * (state.fontPx + 2));
        span.textContent = line;
        t.appendChild(span);
      });
      const bb = t.getBBox();
      const pad = 4;
      const rect = create('rect',{
        x: bb.x - pad,
        y: bb.y - pad,
        width: bb.width + pad*2,
        height: bb.height + pad*2,
        fill: '#ffffff',
        opacity: '0.75'
      }, g);
      g.insertBefore(rect, t);
      return { x: bb.x - pad, y: bb.y - pad, width: bb.width + pad*2, height: bb.height + pad*2 };
    };
    const intersectLineWithRect = (x1,y1,x2,y2, rect) => {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const candidates = [];
      if(dx !== 0){
        const t1 = (rect.x - x1) / dx;
        const y1i = y1 + t1 * dy;
        if(t1 >= 0 && t1 <= 1 && y1i >= rect.y && y1i <= rect.y + rect.height) candidates.push({t:t1,x:rect.x,y:y1i});
        const t2 = (rect.x + rect.width - x1) / dx;
        const y2i = y1 + t2 * dy;
        if(t2 >= 0 && t2 <= 1 && y2i >= rect.y && y2i <= rect.y + rect.height) candidates.push({t:t2,x:rect.x+rect.width,y:y2i});
      }
      if(dy !== 0){
        const t3 = (rect.y - y1) / dy;
        const x3i = x1 + t3 * dx;
        if(t3 >= 0 && t3 <= 1 && x3i >= rect.x && x3i <= rect.x + rect.width) candidates.push({t:t3,x:x3i,y:rect.y});
        const t4 = (rect.y + rect.height - y1) / dy;
        const x4i = x1 + t4 * dx;
        if(t4 >= 0 && t4 <= 1 && x4i >= rect.x && x4i <= rect.x + rect.width) candidates.push({t:t4,x:x4i,y:rect.y+rect.height});
      }
      if(!candidates.length) return null;
      candidates.sort((a,b)=> b.t - a.t);
      return candidates[0];
    };
  if (Array.isArray(state.notes) && state.notes.length) {
    const sw = state.strokeWidth || 1;
      state.notes.forEach(n => {
        const rect = drawNoteText(n.text || '', n.x2, n.y2);
        let ex = n.x2, ey = n.y2;
        if(rect){
          const hit = intersectLineWithRect(n.x1, n.y1, n.x2, n.y2, rect);
          if(hit){ ex = hit.x; ey = hit.y; }
        }
        create('line',{x1:n.x1,y1:n.y1,x2:ex,y2:ey,stroke:'#0f172a','stroke-width':sw}, contentGroup);
        if (state.noteMode === 'edit') {
          create('circle',{cx:ex, cy:ey, r:4, fill:'#0f172a', stroke:'#ffffff', 'stroke-width':1}, contentGroup);
        }
      });
    }
  if (state.notePreview) {
    const sw = state.strokeWidth || 1;
    const n = state.notePreview;
    create('line',{x1:n.x1,y1:n.y1,x2:n.x2,y2:n.y2,stroke:'#0f172a','stroke-width':sw}, contentGroup);
  }

  // popis pouziteho navinu
  // hlavicka nad platnom: dva obdlzniky a text navinu v prvom, dynamicky podla navin bounds
  // bez hlavicky a spodnych textov

  // merania
  drawMeasurements(contentGroup);

  ensureDefs();

  // rotacia celeho vykresu pri navine 1 a duplex (iba tlac)
  if (rotatePrint) {
    const cx = offsetX + L / 2;
    const cy = offsetY + W / 2;
    contentGroup.setAttribute('transform', `rotate(180 ${cx} ${cy})`);
  }

    // viewBox to content (bez mriezky) pre zachovanie mierky
    const vecGroups = Array.from(svgRoot.querySelectorAll('g.vec-shape'));
    const vecDisplays = vecGroups.map(g=> g.getAttribute('display'));
    vecGroups.forEach(g=> g.setAttribute('display','none'));
    const bb = allGroup.getBBox();
    vecGroups.forEach((g,i)=>{
      const d = vecDisplays[i];
      if(d === null) g.removeAttribute('display');
      else g.setAttribute('display', d);
    });
  const pad = 60;
  let minX = Math.floor(bb.x - pad);
  let minY = Math.floor(bb.y - pad);
  let maxX = Math.ceil(bb.x + bb.width + pad);
  let maxY = Math.ceil(bb.y + bb.height + pad);
  if(rollBounds){
    minX = Math.min(minX, rollBounds.minX - pad);
    minY = Math.min(minY, rollBounds.minY - pad);
    maxX = Math.max(maxX, rollBounds.maxX + pad);
    maxY = Math.max(maxY, rollBounds.maxY + pad);
  }
  const width = maxX - minX;
  const height = maxY - minY;
    svgRoot.setAttribute('viewBox', `${minX} ${minY} ${width} ${height}`);
    svgRoot.setAttribute('width', width);
    svgRoot.setAttribute('height', height);

    // update vector bbox after viewBox is set
    if(Array.isArray(state.vecItems)){
      state.vecItems.forEach((v, idx)=>{
        const g = vecGroups.find(el => el.getAttribute('data-vec-idx') === String(idx));
        if(!g || !v || !v.svg){
          if(v) v._bboxSvg = null;
          return;
        }
        const meta = vecMetas[idx];
        const origin = vecOrigins[idx] || {x:0,y:0};
        let bbSvg = computeVecBBox(meta, origin.x, origin.y, v.scale, v.rot);
        let localBB = null;
        let ctm = null;
        if(!bbSvg || !Number.isFinite(bbSvg.width) || bbSvg.width <= 0){
          try{
            localBB = g.getBBox();
            ctm = g.getCTM();
            bbSvg = bboxToSvg(localBB, ctm);
          }catch(_){}
        }
        if((!bbSvg || !Number.isFinite(bbSvg.width) || bbSvg.width <= 0) && g.getBoundingClientRect){
          const r = g.getBoundingClientRect();
          if(r && r.width > 0 && r.height > 0){
            bbSvg = rectToSvgBBox(r);
          }
        }
        v._bboxSvg = bbSvg && Number.isFinite(bbSvg.width) ? bbSvg : null;
        if(idx === state.selectedVec && v._bboxSvg){
          const bb2 = v._bboxSvg;
          create('rect',{x:bb2.x,y:bb2.y,width:bb2.width,height:bb2.height,fill:'none',stroke:'#2563eb','stroke-width':1.5}, contentGroup);
          const r = 4;
          const corners = [
            {x:bb2.x,y:bb2.y, id:'tl'},
            {x:bb2.x+bb2.width,y:bb2.y, id:'tr'},
            {x:bb2.x,y:bb2.y+bb2.height, id:'bl'},
            {x:bb2.x+bb2.width,y:bb2.y+bb2.height, id:'br'}
          ];
          corners.forEach(c=> create('circle',{cx:c.x, cy:c.y, r, fill:'#2563eb','data-handle':c.id}, contentGroup));
        }
      });
    }
  state.bounds = {width,height};
}

function reset(){
  $('W').value=400; $('L').value=600; $('fontPx').value=14; $('fontPxVal').textContent='14 px'; $('toggle-grid').checked=false; $('lineStyle').value='solid';
  $('strokeWidth').value=1; $('dimPos').value='bottom'; $('dimOffset').value=25; $('dimPosH').value='right'; $('dimOffsetH').value=25; $('lineStyleH').value='solid';
  $('units').value='none'; $('decimals').value='0';
  $('rollEnabled').checked=true; $('rollType').value='1'; $('rollVariant').value='A';
  $('strokeWidth').value='0.8';
  $('photoW').value = 15; $('photoH').value = 7;
  state.photoMarks = [];
  state.selectedPhotoIndex = -1;
  $('exportOrient').value='portrait';
  $('bgFile').value=''; state.bgImageData=null; $('bgWidth').value=''; $('bgHeight').value=''; state.bgWidth=null; state.bgHeight=null; state.bgOpacity=0.6; $('bgOpacity').value=0.6; $('bgOpacityVal').textContent='60 %'; state.bgRot=0; state.bgFlip=false; state.bgOffsetX=0; state.bgOffsetY=0; state.lockBg=false; syncLockButtons();
  state.vecItems = []; state.selectedVec = -1; renderVecList();
  $('measureMode').value='off'; state.measureMode='off'; state.measurePick=null; state.measures=[]; state.measurePreview=null;
  setNoteMode('off'); state.noteDraft=null; state.notePreview=null; state.notes=[]; state.noteEditIndex=-1;
  state.calibActive=false; state.calibPoints=[]; $('bg-calib-cancel').style.display='none'; $('bg-calib').style.display='inline-block'; svgRoot.style.cursor='';
  $('segments').innerHTML=''; state.segments.length=0; addSegmentInput('');
  $('segmentsH').innerHTML=''; state.segmentsH.length=0; addSegmentInputH('');
  draw();
}

function exportPDF(){
  draw();
  const liveGroup = svgRoot.querySelector('g.content-bbox') || svgRoot;
  const bb0 = liveGroup.getBBox();
  const pad = 10;
  const bb = { x: bb0.x - pad, y: bb0.y - pad, width: bb0.width + pad*2, height: bb0.height + pad*2 };
  const clone = svgRoot.cloneNode(true);
  // keep navin in PDF export (remove only headers/footers)
  clone.querySelectorAll('.header-ui, .footer-ui').forEach(n=> n.remove());
  const width = bb.width || state.bounds.width || 800;
  const height = bb.height || state.bounds.height || 800;
  const baseName = 'folia_lito';

  clone.setAttribute('viewBox', `${bb.x} ${bb.y} ${bb.width} ${bb.height}`);
  clone.setAttribute('width', `${width}mm`);
  clone.setAttribute('height', `${height}mm`);
  const svgMarkup = new XMLSerializer().serializeToString(clone);
  const html = `<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>${baseName} PDF</title>
  <style>
    @page { size: ${width}mm ${height}mm; margin: 0; }
    body { margin: 0; display:flex; justify-content:center; align-items:center; }
    svg { width:${width}mm; height:${height}mm; }
  </style>
</head>
<body>
${svgMarkup}
<script>window.onload=()=>{ window.print(); setTimeout(()=>window.close(), 500); }<\/script>
</body>
</html>`;
  const blob = new Blob([html], {type:'text/html'});
  const url = URL.createObjectURL(blob);
  const win = window.open(url, '_blank');
  if(!win){ alert('Povolte vyskakovacie okno pre export.'); }
  setTimeout(()=> URL.revokeObjectURL(url), 5000);
}

function exportPNG(){
  const vb = svgRoot.viewBox.baseVal;
  const width = vb.width || state.bounds.width;
  const height = vb.height || state.bounds.height;
  const orient = $('exportOrient')?.value || 'portrait';
  const pxW = orient==='portrait' ? 2480 : 3508; // A4 at 300dpi ~ ok
  const pxH = orient==='portrait' ? 3508 : 2480;
  const marginPx = 0.05 * Math.min(pxW, pxH);
  const usableW = pxW - marginPx*2;
  const usableH = pxH - marginPx*2;
  const bb = svgRoot.getBBox();
  const bbW = bb.width;
  const bbH = bb.height;
  const scale = Math.min(usableW / bbW, usableH / bbH);
  const drawW = bbW * scale;
  const drawH = bbH * scale;
  const offsetX = marginPx + (usableW - drawW) / 2;
  // align to top edge (maximal use of height); bottom will land at margin + drawH
  const offsetY = marginPx;

  const svgCopy = svgRoot.cloneNode(true);
  // remove header boxes, keep only text
  svgCopy.querySelectorAll('.header-ui rect').forEach(n=> n.remove());
  svgCopy.removeAttribute('style');
  svgCopy.setAttribute('width', bbW);
  svgCopy.setAttribute('height', bbH);
  svgCopy.setAttribute('viewBox', `${bb.x} ${bb.y} ${bbW} ${bbH}`);
  svgCopy.setAttribute('preserveAspectRatio','xMidYMid meet');
  const svgMarkup = new XMLSerializer().serializeToString(svgCopy);
  const svgBlob = new Blob([svgMarkup], {type:'image/svg+xml'});
  const url = URL.createObjectURL(svgBlob);
  const img = new Image();
  const baseName = 'folia_lito';
  img.onload = ()=>{
    const canvas = document.createElement('canvas');
    canvas.width = pxW;
    canvas.height = pxH;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,pxW,pxH);
    ctx.drawImage(img, offsetX, offsetY, drawW, drawH);
    canvas.toBlob((blob)=>{
      if(!blob) return;
      const link = document.createElement('a');
      link.download = `${baseName}.png`;
      link.href = URL.createObjectURL(blob);
      link.click();
      URL.revokeObjectURL(link.href);
    }, 'image/png');
    URL.revokeObjectURL(url);
  };
  img.src = url;
}

function collectState(){
  return {
    vz:'folia',
    W:num($('W'),400),
    L:num($('L'),600),
    fontPx:state.fontPx,
    strokeWidth:state.strokeWidth,
    dimPos:$('dimPos')?.value || 'bottom',
    dimOffset:num($('dimOffset'),80),
    dimPosH:$('dimPosH')?.value || 'right',
    dimOffsetH:num($('dimOffsetH'),25),
    lineStyle:$('lineStyle')?.value || 'solid',
    lineStyleH:$('lineStyleH')?.value || 'solid',
    units:state.units,
    decimals:state.decimals,
    rollEnabled:state.rollEnabled,
    rollType:state.rollCode,
    rollVariant:state.rollVariant,
    photoW: state.photoW,
    photoH: state.photoH,
    photoMarks: state.photoMarks,
    selectedPhotoIndex: state.selectedPhotoIndex,
    exportOrient:$('exportOrient')?.value || 'portrait',
    bgWidth:$('bgWidth')?.value || '',
    bgHeight:$('bgHeight')?.value || '',
    bgOpacity:state.bgOpacity,
    bgOffsetX:state.bgOffsetX,
    bgOffsetY:state.bgOffsetY,
      bgRot:state.bgRot,
      bgFlip:state.bgFlip,
      bgImageData:state.bgImageData,
      lockBg: state.lockBg,
      vecItems: Array.isArray(state.vecItems) ? state.vecItems.map(v=>({
        svg: v?.svg || '',
        x: Number.isFinite(v?.x) ? v.x : 0,
        y: Number.isFinite(v?.y) ? v.y : 0,
        scale: Number.isFinite(v?.scale) ? v.scale : 1,
        rot: Number.isFinite(v?.rot) ? v.rot : 0,
        lock: !!v?.lock
      })) : [],
    measures: state.measures,
    measureMode: state.measureMode,
    notes: state.notes,
    segments: state.segments.map(inp=>num(inp,0)),
    segmentsH: state.segmentsH.map(inp=>num(inp,0))
  };
}

function saveJSON(){
  const data = collectState();
  const blob = new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'folia_lito.json'; a.click();
  URL.revokeObjectURL(url);
}

function loadData(data){
  if(!data) return;
  $('W').value = data.W ?? 400;
  $('L').value = data.L ?? 600;
  $('fontPx').value = data.fontPx ?? 14;
  $('strokeWidth').value = data.strokeWidth ?? 1;
  $('dimPos').value = data.dimPos ?? 'bottom';
  $('dimOffset').value = data.dimOffset ?? 80;
  $('dimPosH').value = data.dimPosH ?? 'right';
  $('dimOffsetH').value = data.dimOffsetH ?? 25;
  $('lineStyle').value = data.lineStyle ?? 'solid';
  $('lineStyleH').value = data.lineStyleH ?? 'solid';
  $('units').value = data.units ?? 'mm';
  $('decimals').value = data.decimals ?? 0;
  $('rollEnabled').checked = !!data.rollEnabled;
  $('rollType').value = data.rollType ?? '1';
  $('rollVariant').value = data.rollVariant ?? 'A';
  $('photoW').value = data.photoW ?? 15;
  $('photoH').value = data.photoH ?? 7;
  state.photoW = num($('photoW'),15);
  state.photoH = num($('photoH'),7);
  state.photoMarks = Array.isArray(data.photoMarks) ? data.photoMarks : [];
  state.selectedPhotoIndex = Number.isFinite(data.selectedPhotoIndex) ? data.selectedPhotoIndex : -1;
  $('exportOrient').value = data.exportOrient ?? 'portrait';
  $('bgWidth').value = data.bgWidth ?? '';
  $('bgHeight').value = data.bgHeight ?? '';
  state.bgOpacity = clamp(data.bgOpacity ?? 0.6,0,1);
  $('bgOpacity').value = state.bgOpacity;
  $('bgOpacityVal').textContent = `${Math.round(state.bgOpacity*100)} %`;
  state.bgRot = data.bgRot ?? 0;
  state.bgFlip = !!data.bgFlip;
  state.lockBg = !!data.lockBg;
  syncLockButtons();
  state.bgOffsetX = data.bgOffsetX ?? 0;
  state.bgOffsetY = data.bgOffsetY ?? 0;
  state.bgImageData = data.bgImageData ?? null;
  if (Array.isArray(data.vecItems)) {
    state.vecItems = data.vecItems;
  } else if (data.vecSvg) {
    state.vecItems = [{
      svg: data.vecSvg,
      x: data.vecX ?? 0,
      y: data.vecY ?? 0,
      scale: data.vecScale ?? 1,
      rot: data.vecRot ?? 0,
      lock: false
    }];
  } else {
    state.vecItems = [];
  }
  state.selectedVec = -1;
  renderVecList();
  state.measureMode = data.measureMode ?? 'off';
  $('measureMode').value = state.measureMode;
  state.measures = Array.isArray(data.measures)? data.measures : [];
  state.notes = Array.isArray(data.notes)? data.notes : [];
  $('segments').innerHTML=''; state.segments.length=0;
  (data.segments ?? ['']).forEach(v=> addSegmentInput(v));
  $('segmentsH').innerHTML=''; state.segmentsH.length=0;
  (data.segmentsH ?? ['']).forEach(v=> addSegmentInputH(v));
  draw();
}

function syncRollChecks(changedId){
  const boxes = [
    {id:'rollEnabled', key:'rollEnabled'},
  ];
  const changed = $(changedId);
  if(!changed) return;
  if(changed.checked){
    boxes.forEach(b=>{
      if(b.id !== changedId){
        const el = $(b.id);
        if(el) el.checked = false;
      }
    });
  }
  state.rollEnabled = !!$('rollEnabled')?.checked;
  draw();
}

function handleLoadFile(file){
  if(!file) return;
  const r = new FileReader();
  r.onload = (ev)=>{
    try{
      const data = JSON.parse(ev.target.result);
      if (data.vz && data.vz !== 'folia'){
        alert('Tento JSON je pre iny vzor: ' + data.vz);
        return;
      }
      loadData(data);
    }catch(_){ }
  };
  r.readAsText(file);
}

function getSvgPoint(evt){
  const pt = svgRoot.createSVGPoint();
  pt.x = evt.clientX; pt.y = evt.clientY;
  const ctm = svgRoot.getScreenCTM();
  if(!ctm) return {x:0,y:0};
  const inv = ctm.inverse();
  const sp = pt.matrixTransform(inv);
  return {x:sp.x, y:sp.y};
}

function startCalib(){
  if(!state.bgImageData){ alert('Najprv vloz podklad.'); return; }
  state.calibActive=true; state.calibPoints=[];
  $('bg-calib').style.display='none';
  $('bg-calib-cancel').style.display='inline-block';
  svgRoot.style.cursor='crosshair';
}
function cancelCalib(){
  state.calibActive=false; state.calibPoints=[];
  $('bg-calib').style.display='inline-block';
  $('bg-calib-cancel').style.display='none';
  svgRoot.style.cursor='';
}

function applyCalibIfReady(){
  if(state.calibPoints.length<2) return;
  const [p1,p2]=state.calibPoints;
  const dist = Math.hypot(p2.x-p1.x, p2.y-p1.y);
  const mmStr = prompt('Zadaj skutocnu vzdialenost medzi bodmi (mm):','100');
  const mmVal = parseFloat(mmStr);
  if(Number.isFinite(mmVal) && mmVal>0 && dist>0){
    const factor = mmVal / dist;
    const curW = state.bgWidth ?? num($('L'),600);
    const curH = state.bgHeight ?? num($('W'),400);
    state.bgWidth = curW * factor;
    state.bgHeight = curH * factor;
    $('bgWidth').value = state.bgWidth.toFixed(1);
    $('bgHeight').value = state.bgHeight.toFixed(1);
  }
  cancelCalib();
  draw();
}

function handleSvgClick(e){
  const p = getSvgPoint(e);
  if(state.calibActive){
    state.calibPoints.push(p);
    applyCalibIfReady();
    return;
  }
  if(state.noteMode === 'on' || state.noteMode === 'edit'){
    // edit existing note if clicked near text anchor
    if (Array.isArray(state.notes)) {
      for (let i = state.notes.length - 1; i >= 0; i--) {
        const n = state.notes[i];
        const dx = Math.abs(p.x - n.x2);
        const dy = Math.abs(p.y - n.y2);
        if (dx <= 20 && dy <= 20) {
          state.noteEditIndex = i;
          if(state.noteMode === 'edit'){
            const input = $('noteInput');
            if (input) {
              input.style.display = 'block';
              input.style.left = (e.clientX + 8) + 'px';
              input.style.top = (e.clientY + 8) + 'px';
              input.value = n.text || '';
              input.focus();
            }
          }
          return;
        }
      }
    }
    if(state.noteMode === 'on'){
      if(!state.noteDraft){
        state.noteDraft = {x1:p.x,y1:p.y};
        state.notePreview = {x1:p.x,y1:p.y,x2:p.x,y2:p.y};
        return;
      }
      if(!state.noteDraft.x2){
        state.noteDraft.x2 = p.x; state.noteDraft.y2 = p.y;
        state.notePreview = null;
        const input = $('noteInput');
        if (input) {
          input.style.display = 'block';
          input.style.left = (e.clientX + 8) + 'px';
          input.style.top = (e.clientY + 8) + 'px';
          input.value = '';
          input.focus();
        }
        return;
      }
    }
  }
  if(state.measureMode==='off') return;
  if(!state.measurePick){
    state.measurePick = p;
  }else{
    if(state.measureMode==='h'){
      state.measures.push({type:'h',x1:state.measurePick.x,y1:p.y,x2:p.x,y2:p.y});
    }else if(state.measureMode==='v'){
      state.measures.push({type:'v',x1:p.x,y1:state.measurePick.y,x2:p.x,y2:p.y});
    }
    state.measurePick=null; state.measurePreview=null;
    draw();
  }
}
function handleSvgMove(e){
  if(state.calibActive) return;
  if(state.noteMode==='on' && state.noteDraft && !state.noteDraft.x2){
    const p = getSvgPoint(e);
    state.notePreview = {x1:state.noteDraft.x1,y1:state.noteDraft.y1,x2:p.x,y2:p.y};
    draw();
    return;
  }
  if(state.measureMode==='off') return;
  if(!state.measurePick) return;
  const p = getSvgPoint(e);
  if(state.measureMode==='h'){
    state.measurePreview = {type:'h',x1:state.measurePick.x,y1:state.measurePick.y,x2:p.x,y2:state.measurePick.y};
  }else if(state.measureMode==='v'){
    state.measurePreview = {type:'v',x1:state.measurePick.x,y1:state.measurePick.y,x2:state.measurePick.x,y2:p.y};
  }
  draw();
}

inputs.forEach(el=> el && el.addEventListener('input', draw));
$('btn-reset')?.addEventListener('click', reset);
$('btn-export')?.addEventListener('click', ()=>{ draw(); exportPDF(); });
$('btn-export-png')?.addEventListener('click', ()=>{ draw(); exportPNG(); });
$('btn-save')?.addEventListener('click', saveJSON);
$('btn-load')?.addEventListener('click', ()=> $('loadFile')?.click());
$('loadFile')?.addEventListener('change', (e)=> handleLoadFile(e.target.files?.[0]));
$('seg-add')?.addEventListener('click', ()=> addSegmentInput(''));
$('seg-remove')?.addEventListener('click', removeSegmentInput);
$('segH-add')?.addEventListener('click', ()=> addSegmentInputH(''));
$('segH-remove')?.addEventListener('click', removeSegmentInputH);
$('rollEnabled')?.addEventListener('change', ()=> syncRollChecks('rollEnabled'));

$('bgFile')?.addEventListener('change', (e)=>{
  const file = e.target.files && e.target.files[0];
  if(!file) return;
  const r = new FileReader();
  r.onload = (ev)=>{ state.bgImageData = ev.target.result; draw(); };
  r.readAsDataURL(file);
});
  $('bg-lock')?.addEventListener('click', ()=>{
    state.lockBg = !state.lockBg;
    syncLockButtons();
  });
  $('vec-add')?.addEventListener('click', ()=>{
    state.vecItems.push({svg:'', x:0, y:0, scale:1, rot:0, lock:false});
    renderVecList();
    setSelectedVec(state.vecItems.length - 1);
  });
$('bg-rot-left')?.addEventListener('click', ()=>{ state.bgRot = (state.bgRot - 90); draw(); });
$('bg-rot-180')?.addEventListener('click', ()=>{ state.bgRot = (state.bgRot + 180); draw(); });
$('bg-flip')?.addEventListener('click', ()=>{ state.bgFlip = !state.bgFlip; draw(); });
$('bgOpacity')?.addEventListener('input', ()=>{ state.bgOpacity = clamp(num($('bgOpacity'), 0.6),0,1); $('bgOpacityVal').textContent = `${Math.round(state.bgOpacity*100)} %`; draw(); });
$('bgWidth')?.addEventListener('input', ()=>{ state.bgWidth = $('bgWidth').value ? num($('bgWidth'), state.bgWidth) : null; draw(); });
$('bgHeight')?.addEventListener('input', ()=>{ state.bgHeight = $('bgHeight').value ? num($('bgHeight'), state.bgHeight) : null; draw(); });
$('bg-clear')?.addEventListener('click', ()=>{ state.bgImageData=null; state.bgWidth=null; state.bgHeight=null; state.bgOffsetX=0; state.bgOffsetY=0; $('bgFile').value=''; $('bgWidth').value=''; $('bgHeight').value=''; draw(); });
$('bg-calib')?.addEventListener('click', startCalib);
$('bg-calib-cancel')?.addEventListener('click', cancelCalib);

$('measureMode')?.addEventListener('change', ()=>{ state.measureMode = $('measureMode').value; state.measurePick=null; state.measurePreview=null; draw(); });
$('measure-cancel')?.addEventListener('click', ()=>{ state.measurePick=null; state.measurePreview=null; draw(); });
$('measure-clear')?.addEventListener('click', ()=>{ state.measures=[]; state.measurePick=null; state.measurePreview=null; draw(); });
  $('note-add')?.addEventListener('click', ()=>{
    const next = (state.noteMode === 'on') ? 'off' : 'on';
    setNoteMode(next);
    state.noteEditIndex = -1;
    state.noteDraft = null;
    state.notePreview = null;
  });
  $('note-edit')?.addEventListener('click', ()=>{
    const next = (state.noteMode === 'edit') ? 'off' : 'edit';
    setNoteMode(next);
    state.noteEditIndex = -1;
    state.noteDraft = null;
    state.notePreview = null;
  });
$('note-delete')?.addEventListener('click', ()=>{
  if (state.notes.length) {
    state.notes.pop();
    draw();
  }
});
$('noteInput')?.addEventListener('keydown', (e)=>{
  if(e.key==='Enter' && !e.shiftKey){
    e.preventDefault();
    e.target.blur();
  }
});
  $('noteInput')?.addEventListener('blur', (e)=>{
    if(state.noteMode !== 'on' && state.noteMode !== 'edit') { e.target.style.display='none'; return; }
    const text = e.target.value.trim();
    if(state.noteEditIndex >= 0){
      if(state.notes[state.noteEditIndex]) state.notes[state.noteEditIndex].text = text;
      state.noteEditIndex = -1;
  } else if(state.noteDraft && state.noteDraft.x2 != null){
    if(text){
      state.notes.push({x1:state.noteDraft.x1,y1:state.noteDraft.y1,x2:state.noteDraft.x2,y2:state.noteDraft.y2,text});
    }
  }
    state.noteDraft = null;
    state.notePreview = null;
    e.target.value = '';
    e.target.style.display='none';
    setNoteMode('off');
    draw();
  });
  document.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape' && (state.noteMode === 'on' || state.noteMode === 'edit')){
      state.noteDraft = null;
      state.notePreview = null;
      setNoteMode('off');
      draw();
    }
  });
$('photo-add')?.addEventListener('click', ()=>{
  const dims = state.drawDims || {offsetX:60, offsetY:80, L:600, W:400};
  const markW = Math.max(1, Number.isFinite(state.photoW) ? state.photoW : 15);
  const markH = Math.max(1, Number.isFinite(state.photoH) ? state.photoH : 7);
  const x = dims.offsetX + (dims.L - markW) / 2;
  const y = dims.offsetY - markH / 2;
  state.photoMarks.push({x, y, showDims:false});
  state.selectedPhotoIndex = state.photoMarks.length - 1;
  const dimsChk = $('photo-dims');
  if (dimsChk) dimsChk.checked = false;
  draw();
});
$('photo-remove')?.addEventListener('click', ()=>{
  if (state.photoMarks.length) {
    state.photoMarks.pop();
    if (state.selectedPhotoIndex >= state.photoMarks.length) state.selectedPhotoIndex = state.photoMarks.length - 1;
    draw();
  }
});
$('photo-dims')?.addEventListener('change', (e)=>{
  const idx = state.selectedPhotoIndex;
  if (idx == null || idx < 0 || idx >= state.photoMarks.length) return;
  state.photoMarks[idx].showDims = !!e.target.checked;
  draw();
});

svgRoot.addEventListener('click', handleSvgClick);
svgRoot.addEventListener('mousemove', handleSvgMove);

let draggingBg=false, dragStart=null;
let draggingMark=false, dragMarkIndex=-1, dragMarkOffset=null;
let draggingNote=false, dragNoteOffset=null;
let draggingVec=false, dragVecOffset=null;
let resizingVec=false, resizeHandle=null, resizeStart=null;
  svgRoot.addEventListener('pointerdown',(e)=>{
  if(state.calibActive) return;
  if(state.measureMode!=='off') return;
  if(state.noteMode==='on' || state.noteMode==='edit'){
    const p = getSvgPoint(e);
    if (Array.isArray(state.notes)) {
      for (let i = state.notes.length - 1; i >= 0; i--) {
        const n = state.notes[i];
        const dx = Math.abs(p.x - n.x2);
        const dy = Math.abs(p.y - n.y2);
        if (dx <= 20 && dy <= 20) {
          draggingMark = false;
          draggingBg = false;
          state.noteEditIndex = i;
          dragMarkIndex = -1;
          state.noteDraft = null;
          state.notePreview = null;
          if(state.noteMode === 'edit'){
            draggingNote = true;
            dragNoteOffset = { dx: p.x - n.x2, dy: p.y - n.y2 };
            svgRoot.setPointerCapture(e.pointerId);
          }
          return;
        }
      }
    }
    return;
  }
  if(e.button!==0) return;
    const p = getSvgPoint(e);
    // vector select/drag
    if(Array.isArray(state.vecItems) && state.vecItems.length){
      const selIdx = state.selectedVec;
      if(selIdx >= 0){
        const v = state.vecItems[selIdx];
        const bbSvg = v && v._bboxSvg;
        if(v && !v.lock && bbSvg){
          const handles = [
            {x:bbSvg.x,y:bbSvg.y, id:'tl'},
            {x:bbSvg.x+bbSvg.width,y:bbSvg.y, id:'tr'},
            {x:bbSvg.x,y:bbSvg.y+bbSvg.height, id:'bl'},
            {x:bbSvg.x+bbSvg.width,y:bbSvg.y+bbSvg.height, id:'br'}
          ];
          for(const h of handles){
            if(Math.abs(p.x - h.x) <= 6 && Math.abs(p.y - h.y) <= 6){
              resizingVec = true;
              resizeHandle = h.id;
              resizeStart = {x:p.x,y:p.y, bb:{...bbSvg}, scale:v.scale, idx:selIdx};
              svgRoot.setPointerCapture(e.pointerId);
              return;
            }
          }
        }
      }
      for(let i = state.vecItems.length - 1; i >= 0; i--){
        const v = state.vecItems[i];
        const bbSvg = v && v._bboxSvg;
        if(!v || v.lock || !bbSvg) continue;
        if(p.x >= bbSvg.x && p.x <= bbSvg.x + bbSvg.width && p.y >= bbSvg.y && p.y <= bbSvg.y + bbSvg.height){
          setSelectedVec(i);
          draggingVec = true;
          dragVecOffset = { x: p.x, y: p.y, vecX: v.x, vecY: v.y, idx:i };
          svgRoot.setPointerCapture(e.pointerId);
          draw();
          return;
        }
      }
    }
  const markW = Math.max(1, Number.isFinite(state.photoW) ? state.photoW : 15);
  const markH = Math.max(1, Number.isFinite(state.photoH) ? state.photoH : 7);
  if (Array.isArray(state.photoMarks)) {
    for (let i = state.photoMarks.length - 1; i >= 0; i--) {
      const m = state.photoMarks[i];
      if (p.x >= m.x && p.x <= m.x + markW && p.y >= m.y && p.y <= m.y + markH) {
        draggingMark = true;
        dragMarkIndex = i;
        dragMarkOffset = { dx: p.x - m.x, dy: p.y - m.y };
        state.selectedPhotoIndex = i;
        const dims = $('photo-dims');
        if (dims) dims.checked = !!state.photoMarks[i].showDims;
        svgRoot.setPointerCapture(e.pointerId);
        return;
      }
    }
  }
    // click on empty space clears selection
    setSelectedVec(-1);
    state.selectedPhotoIndex = -1;
    const dims = $('photo-dims');
    if (dims) dims.checked = false;
    if(!state.lockBg){
      draggingBg=true;
      dragStart = {x:e.clientX,y:e.clientY,ox:state.bgOffsetX,oy:state.bgOffsetY};
      svgRoot.setPointerCapture(e.pointerId);
    }
  });
svgRoot.addEventListener('pointermove',(e)=>{
  if(draggingMark){
    const p = getSvgPoint(e);
    const dims = state.drawDims || {offsetX:0, offsetY:0, L:0, W:0};
    const markW = Math.max(1, Number.isFinite(state.photoW) ? state.photoW : 15);
    const markH = Math.max(1, Number.isFinite(state.photoH) ? state.photoH : 7);
    let nx = p.x - (dragMarkOffset?.dx || 0);
    let ny = p.y - (dragMarkOffset?.dy || 0);
    // horizontal clamp to drawing width, vertical free
    if (Number.isFinite(dims.L)) {
      const minX = dims.offsetX;
      const maxX = dims.offsetX + dims.L - markW;
      nx = Math.max(minX, Math.min(maxX, nx));
    }
    state.photoMarks[dragMarkIndex] = { x: nx, y: ny };
    draw();
    return;
  }
  if(draggingNote && state.noteEditIndex >= 0){
    const p = getSvgPoint(e);
    const n = state.notes[state.noteEditIndex];
    if(n){
      n.x2 = p.x - (dragNoteOffset?.dx || 0);
      n.y2 = p.y - (dragNoteOffset?.dy || 0);
      draw();
    }
    return;
  }
  if(resizingVec && resizeStart){
    const idx = resizeStart.idx;
    const v = Array.isArray(state.vecItems) ? state.vecItems[idx] : null;
    if(!v || v.lock) return;
    const p = getSvgPoint(e);
    const bb = resizeStart.bb;
    let newW = bb.width;
    let newH = bb.height;
    if(resizeHandle==='br'){
      newW = Math.max(5, p.x - bb.x);
      newH = Math.max(5, p.y - bb.y);
    }else if(resizeHandle==='tr'){
      newW = Math.max(5, p.x - bb.x);
      newH = Math.max(5, bb.y + bb.height - p.y);
    }else if(resizeHandle==='bl'){
      newW = Math.max(5, bb.x + bb.width - p.x);
      newH = Math.max(5, p.y - bb.y);
    }else if(resizeHandle==='tl'){
      newW = Math.max(5, bb.x + bb.width - p.x);
      newH = Math.max(5, bb.y + bb.height - p.y);
    }
    const scaleX = newW / bb.width;
    const scaleY = newH / bb.height;
    const scale = Math.max(0.05, Math.min(scaleX, scaleY));
    v.scale = resizeStart.scale * scale;
    const scaleInput = $(`vec-scale-${idx}`);
    if (scaleInput) scaleInput.value = Math.round(v.scale * 100);
    draw();
    return;
  }
  if(draggingVec){
    const idx = dragVecOffset?.idx;
    const v = Array.isArray(state.vecItems) ? state.vecItems[idx] : null;
    if(!v || v.lock) return;
    const p = getSvgPoint(e);
    const start = dragVecOffset || {x:p.x, y:p.y, vecX:v.x, vecY:v.y};
    v.x = start.vecX + (p.x - start.x);
    v.y = start.vecY + (p.y - start.y);
    draw();
    return;
  }
    if(!draggingBg) return;
    if(state.lockBg) return;
  const dx = e.clientX - dragStart.x;
  const dy = e.clientY - dragStart.y;
  const ctm = svgRoot.getScreenCTM();
  const scaleX = ctm ? ctm.a : 1;
  const scaleY = ctm ? ctm.d : 1;
  state.bgOffsetX = dragStart.ox + dx / scaleX;
  state.bgOffsetY = dragStart.oy + dy / scaleY;
  draw();
});
svgRoot.addEventListener('pointerup', ()=>{ draggingBg=false; draggingMark=false; dragMarkIndex=-1; dragMarkOffset=null; draggingNote=false; dragNoteOffset=null; draggingVec=false; dragVecOffset=null; resizingVec=false; resizeHandle=null; resizeStart=null; });
svgRoot.addEventListener('pointercancel', ()=>{ draggingBg=false; draggingMark=false; dragMarkIndex=-1; dragMarkOffset=null; draggingNote=false; dragNoteOffset=null; draggingVec=false; dragVecOffset=null; resizingVec=false; resizeHandle=null; resizeStart=null; });

window.addEventListener('paste',(e)=>{
  const items = Array.from(e.clipboardData?.items||[]);
  const it = items.find(i=> i.type && i.type.startsWith('image/'));
  if(!it) return;
  const file = it.getAsFile();
  if(!file) return;
  const r=new FileReader();
  r.onload=(ev)=>{ state.bgImageData = ev.target.result; draw(); };
  r.readAsDataURL(file);
  e.preventDefault();
});

addSegmentInput('');
addSegmentInputH('');
reset();

</script>
</body>
</html>

